---
title: "BraveRatsThesis"
code-fold: true
self-contained: true
format:
  html:
    toc: true
editor: visual
---

# Setup

allTurns = optimal gameplay data
braverats = human data

```{r packages-setup}
#| warning: false

library(tidyverse)
library(tidyclust)
library(tclust)
library(tidymodels)
library(knitr)
```

## Nash optimal data

```{r import-optimal}
# Main data
# Previous filename: "SolutionFiles/optimalSolutionNew.txt"

allTurns <- read.csv("SolutionFiles/updatedOptimalSolution.txt", header = FALSE, sep = "|", col.names = c("gamestate", "value", "s1_type","p1_optimal","s2_type", "p2_optimal", ".m", "value_matrix")) %>% 
  mutate(gamestate = substr(gamestate,1, nchar(gamestate)-2)) %>%
  mutate(gamestate_str = gamestate) %>% #Making a copy to be used as row labels
  separate(gamestate, c(".1", "p1_cards", ".2", "p2_cards", ".3", "wins", ".4", "generals", ".5", "spies", ".6", "holds"), sep = "-")

rownames(allTurns) <- allTurns$gamestate_str
allTurns <- allTurns %>% 
  separate(p1_optimal, paste("p1_o", 0:7, sep=''), sep=",", convert = TRUE) %>% 
  separate(p2_optimal, paste("p2_o", 0:7, sep=''), sep=",", convert = TRUE)

allTurns <- allTurns %>% select(-starts_with(".")) # get rid of temp columns starting with "."
allTurns <- allTurns %>% mutate(cards_left = nchar(p1_cards),
                                turn = 9-cards_left) %>% 
  mutate(p1_c0 = grepl("0",p1_cards),
          p1_c1 = grepl("1",p1_cards),
          p1_c2 = grepl("2",p1_cards),
          p1_c3 = grepl("3",p1_cards),
          p1_c4 = grepl("4",p1_cards),
          p1_c5 = grepl("5",p1_cards),
          p1_c6 = grepl("6",p1_cards),
          p1_c7 = grepl("7",p1_cards),
          p2_c0 = grepl("0",p2_cards),
          p2_c1 = grepl("1",p2_cards),
          p2_c2 = grepl("2",p2_cards),
          p2_c3 = grepl("3",p2_cards),
          p2_c4 = grepl("4",p2_cards),
          p2_c5 = grepl("5",p2_cards),
          p2_c6 = grepl("6",p2_cards),
          p2_c7 = grepl("7",p2_cards),
          p1_wins = as.numeric(substring(wins, 1,1)),
         p2_wins = as.numeric(substring(wins, 2,2)),
         p1_general = substring(generals, 1,1)==1,
         p2_general = substring(generals, 2,2)==1,
         p1_spy = substring(spies, 1,1)==1,
         p2_spy = substring(spies,2,2)==1,
         p1_holds = as.numeric(substring(holds,1,1)),
         p2_holds = as.numeric(substring(holds,2,2))
         )

# For response turns, we have a separate distribution of (equal) probabilities for each opponent's choice
response_turns <- allTurns %>% 
  filter(s1_type == "s1r") %>% 
  # Each "optimal" here is whether 
  pivot_longer(cols = c("p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7"), names_to = "responding_to_card", values_to = "optimal_responses") %>% 
  mutate(responding_to_card = as.numeric(substring(responding_to_card,5,6))) %>% 
  filter(optimal_responses!="") %>% # Cards opponent doesn't have have "" optimal strings
  mutate(num_possibilities = str_length(optimal_responses),
         p1_o0 = ifelse(p1_c0, ifelse(grepl("0",optimal_responses), 1/num_possibilities, 0), NA),
         p1_o1 = ifelse(p1_c1, ifelse(grepl("1",optimal_responses), 1/num_possibilities, 0), NA),
         p1_o2 = ifelse(p1_c2, ifelse(grepl("2",optimal_responses), 1/num_possibilities, 0), NA),
         p1_o3 = ifelse(p1_c3, ifelse(grepl("3",optimal_responses), 1/num_possibilities, 0), NA),
         p1_o4 = ifelse(p1_c4, ifelse(grepl("4",optimal_responses), 1/num_possibilities, 0), NA),
         p1_o5 = ifelse(p1_c5, ifelse(grepl("5",optimal_responses), 1/num_possibilities, 0), NA),
         p1_o6 = ifelse(p1_c6, ifelse(grepl("6",optimal_responses), 1/num_possibilities, 0), NA),
         p1_o7 = ifelse(p1_c7, ifelse(grepl("7",optimal_responses), 1/num_possibilities, 0), NA)
  ) %>% 
  select(-num_possibilities, -optimal_responses)

normal_turns <- allTurns %>% 
  filter(s1_type != "s1r") %>% 
  mutate(responding_to_card = NA) # This indicates that this entry is not a response to an opponent's spied card



allOptimalStrategies <- rbind(normal_turns, response_turns) %>% 
  mutate(across(matches("^P[12]_o"), ~as.numeric(.))) # Turn all "optimal probability" to numeric

# Saving Memory
remove(response_turns)
remove(normal_turns)

# Lists of optimal strategy columns
# c("p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7")
# c("p2_o0","p2_o1","p2_o2","p2_o3","p2_o4","p2_o5","p2_o6","p2_o7")
```

```{r}
# A dataframe of just the optimal probabilities (0 for non-possibilities)
# Used for clustering later

p1_optimal_turns <- allOptimalStrategies %>% 
  #filter(turn <=5) %>% 
  filter(p1_spy == 0 & p2_spy == 0) %>% 
  select("p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7") %>% 
  mutate_all(~replace(., is.na(.), 0))
```

## Human data

```{r read-human-data}
#braverats <- read.csv("BraveRatsData.csv")
source("readHumanData.r")
```

```{r human-joined-ai}
joined_human_ai <- braverats %>% left_join(allOptimalStrategies, by=c(paste("p1_c", 0:7, sep=''), paste("p2_c", 0:7, sep=''), 
                                                "p1_wins", "p2_wins", "p1_holds", "p2_holds",
                                                "p1_spy", "p2_spy", "p1_general", "p2_general", "responding_to_card"))
```

```{r}
#| label: player-optimal-data-reshaping

played_vs_optimal <- joined_human_ai %>% 
  pivot_longer(cols = c("p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7"), names_to = "card_untrimmed", values_to = "optimal_prob") %>%
  mutate(this_card = substring(card_untrimmed, 5,6),
         this_card_played = if_else(P1==this_card, 1, 0),
         actual_card_played = P1,
         turn_type = ifelse(p1_spy, "Going Second", ifelse(p2_spy, "Going first", "Simultaneous"))) %>% 
  select(Game, turn, p1_name, this_card, this_card_played, actual_card_played, optimal_prob, gamestate_str, p1_spy, p2_spy, turn_type) %>% 
  filter(!is.na(optimal_prob)) # Removing invalid cards

#played_vs_optimal %>% sample_n(8)
```

# EDA

## Number of turns

Number of (non-terminal) states for each turn of game

```{r}
allTurns %>% 
  ggplot(aes(x = turn)) +
  geom_histogram()

allTurns %>% 
  group_by(turn) %>% 
  summarize(count = n())
```

Distinct strategies by turn (counting multiple strategies on spy turns)

```{r}
allOptimalStrategies %>% 
  ggplot(aes(x = turn)) +
  geom_histogram()

allOptimalStrategies %>% 
  group_by(turn) %>% 
  summarize(count = n())
```

## Values of the turns

```{r}
# This is symmetrical, how to make it look like it?
mean(allTurns$value)

allTurns %>% 
  ggplot(aes(x = value)) +
  geom_histogram(binwidth = 0.1)
```

#### Plots of value by turn

```{r}
# Setting the bounds to make buckets symmetrical about 0.5.
# In order to achieve symmetry there must also be no datapoints on any breakpoints, so I widen them a tiny bit
# There are 21 buckets of just over 0.05 size.
lower_bound <- -0.025 + 0.000001
upper_bound <- 1.025 - 0.000001
breaks <- seq(lower_bound, upper_bound, by = ((upper_bound -lower_bound)/(21)))
#breaks <- seq(-0.05, 1.05, by = 0.1)

data_buckets <- cut(allTurns$value, breaks = breaks, include.lowest = TRUE)
table(data_buckets)
allTurns %>% 
  filter(value == 0.025)

allTurns %>% 
  mutate(turn = paste0("Turn ", turn)) %>% 
  ggplot(aes(x = value)) +
  geom_histogram(aes(y = ..density..), fill = 'grey5', color = "grey20", breaks = breaks) +
  facet_grid(rows = vars(turn), scales = "free_y", switch = "y")  +
  theme_minimal() +
  theme(
    strip.text.y.left = element_text(angle = 0, hjust = 0.5), # Rotate facet labels upright
    
    axis.line.y = element_blank(), # Hide the left y-axis line
    axis.text.y.left = element_blank(), # Hide the left y-axis text
    axis.ticks.y.left = element_blank(), # Hide the left y-axis ticks
    axis.title.y = element_blank(), # Remove y-axis label

    #panel.grid.major.y = element_line(), # Customize grid line appearance
    panel.grid.minor.y = element_blank() # Remove minor grid lines

  ) +
  labs(title = "Distribution of Values by Turn",
         x = "Value of Game State",
         y = "Proportion")
```

#### Proportion of turns that are either 1 or 0 by turn

```{r}
allTurns %>% 
  mutate(turnType = ifelse(value==0 | value==1, "Value = 0 or 1", ifelse(value == 0.5, "Value = 0.5", "Other"))) %>% 
  #mutate(turnType = ifelse(value==0, "Value = 0", ifelse(value==1, "Value = 1", "Value = 0.5"))) %>% 
  group_by(turnType, turn) %>% 
  summarize(n = n()) %>% 
  pivot_wider(names_from = turnType, values_from = n, values_fill = 0) %>% 
  arrange(turn)
```


# Exploration of MiniMax

## Average optimal by card

For each card, the distribution of what its optimal probability is when it's an option.

```{r}
card_optimals <- allOptimalStrategies %>% 
  pivot_longer(cols = c("p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7"), names_prefix="p1_o", names_to = "card", values_to = "optimal_prob") %>% 
  filter(!is.na(optimal_prob))

card_optimals %>% 
  #filter(spies == "00") %>% 
  filter(turn == 6) %>% 
  ggplot(aes(x = optimal_prob)) +
  geom_histogram(breaks = seq(0, 1, by=0.1)) +
  facet_grid(rows = vars(card))
```

Average of each card, by turn

```{r}
card_avg_by_turn <- card_optimals %>% 
  #filter(spies == "00") %>% 
  select(card,turn,optimal_prob) %>% 
  filter(!is.na(optimal_prob)) %>% 
  group_by(card,turn) %>% 
  summarize(avg_prob = mean(optimal_prob),
            sd = sd(optimal_prob)) 

# Avg probs by turn
card_avg_by_turn %>% 
  select(card, avg_prob, turn) %>% 
  pivot_wider(names_from = card, values_from = avg_prob) %>% 
  round(2)


# Sd of optimal probs by turn
card_avg_by_turn %>% 
  select(card, sd, turn) %>% 
  pivot_wider(names_from = card, values_from = sd) %>% 
  round(2)

# Adjusted probabilities
card_avg_by_turn %>% 
  mutate(
    uniform_prob = 1 / (9-turn), # Uniform distribution's probability
    adjusted_avg_prob = avg_prob /uniform_prob) %>% 
  select(card, adjusted_avg_prob, turn) %>% 
  pivot_wider(names_from = card, values_from = adjusted_avg_prob) %>% 
  round(2)




card_avg_by_turn %>% 
  ggplot(aes(x = turn, y = avg_prob, color = card)) +
  geom_line()
```

# Spy turns

Given that card X is in hand and you've been spied, how often is card X optimal to play?

This table is split by turn of game. Contrary to prior belief, card 0 is not the overwhelming preferrence even when it's an option (\<50% until turn 5).

```{r}
allOptimalStrategies %>% 
  filter(p2_spy==1) %>% 
  group_by(turn) %>% 
  summarize(across(c("p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7"), ~mean(.x, na.rm=TRUE)))
```

A manual survey of what cards are optimal during different turns.

```{r}
spy_optimal_cards <- allOptimalStrategies %>% 
  filter(p2_spy==TRUE) %>% 
  #select(p1_cards, p2_cards, "p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7", "p2_o0","p2_o1","p2_o2","p2_o3","p2_o4","p2_o5","p2_o6","p2_o7") %>% 
  # Extracting the optimal card for each player
  pivot_longer(cols = c( "p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7"), names_to = "p1_card", values_to = "optimal_prob") %>% 
  filter(optimal_prob==1) %>% 
  mutate(p1_card=as.factor(substring(p1_card,5,6))) %>% 
  select(-optimal_prob) %>% 
  pivot_longer(cols = c("p2_o0","p2_o1","p2_o2","p2_o3","p2_o4","p2_o5","p2_o6","p2_o7"), names_to = "p2_card", values_to = "optimal_prob") %>% 
  filter(optimal_prob==1) %>% 
  mutate(p2_card=as.factor(substring(p2_card,5,6))) %>% 
  select(-optimal_prob)

spy_optimal_cards %>% 
  filter(turn<=3) %>% 
  select(p1_cards, p2_cards,wins, generals, holds, p1_card, p2_card) %>% 
  sample_n(10)
```

### Decision tree for spy turns

```{r}
library(rpart)

library(rpart.plot)


tree_mod <- decision_tree(mode = "classification", tree_depth = 3, cost_complexity = double(1)) %>%
  set_engine("rpart") %>%
  set_mode("classification")

spy_recipe = recipe(p1_card ~ #p1_c0+p1_c1+p1_c2+p1_c3+p1_c4+p1_c5+p1_c6+p1_c7+ # All gamestate information
          p2_c0+p2_c1+p2_c2+p2_c3+p2_c4+p2_c5+p2_c6+p2_c7+
          p1_wins+
         p2_wins+
         p1_general+p2_general+
         #p1_spy+p2_spy+
         p1_holds+p2_holds, data = spy_optimal_cards)

spy_wf = workflow() %>%
  add_recipe(spy_recipe) %>%
  add_model(tree_mod)

spy_fit <- spy_wf %>% fit(spy_optimal_cards)

tree_fitted <- spy_fit %>% 
  extract_fit_parsnip()

tree_fitted

rpart.plot(tree_fitted$fit)
```

# Analysis of viability

In this section I use decision trees to see how easy it is to tell whether a card is "viable" in a certain situation or not. A card is "viable" if the optimal probability to play it is above 0.

```{r}
# This dataset looks card-by-card whether each card is viable in a particular gamestate.
# The idea is that if it's simple to tell which cards are viable, we can more easily figure out the play patterns that will work

card_viability <- allOptimalStrategies %>% 
  filter(p2_spy==FALSE, turn <8) %>% 
  # Extracting the optimal card for each player
  pivot_longer(cols = c( "p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7"), names_to = "p1_card", values_to = "p1_optimal_prob") %>% 
  filter(!is.na(p1_optimal_prob)) %>% 
  mutate(p1_card=as.factor(substring(p1_card,5,6)),
         p1_card_viable = ifelse(p1_optimal_prob>0,"viable","not viable"))
  

# card_viability %>% sample_n(10)
```

We'll make a tree for each card (I'll just do a few for now to illustrate).

For card 0 (musician)

```{r}
card_of_interest = 0 # Doing each card's tree 1 at a time

tree_mod <- decision_tree(mode = "classification", tree_depth = 3, cost_complexity = double(1)) %>%
  set_engine("rpart") %>%
  set_mode("classification")

spy_recipe = recipe(p1_card_viable ~ #p1_c0+p1_c1+p1_c2+p1_c3+p1_c4+p1_c5+p1_c6+p1_c7+ # All gamestate information
          p2_c0+p2_c1+p2_c2+p2_c3+p2_c4+p2_c5+p2_c6+p2_c7+
          p1_wins+
         p2_wins+
         p1_general+p2_general+
         #p1_spy+p2_spy+
         p1_holds+p2_holds, data = card_viability)

spy_wf = workflow() %>%
  add_recipe(spy_recipe) %>%
  add_model(tree_mod)

spy_fit <- spy_wf %>% fit(card_viability %>% filter(p1_card==card_of_interest))

tree_fitted <- spy_fit %>% 
  extract_fit_parsnip()

tree_fitted

rpart.plot(tree_fitted$fit)
```

For princess (1)

```{r}
card_of_interest = 1 # Doing each card's tree 1 at a time

tree_mod <- decision_tree(mode = "classification", tree_depth = 4, cost_complexity = double(1)) %>%
  set_engine("rpart") %>%
  set_mode("classification")

spy_recipe = recipe(p1_card_viable ~ #p1_c0+p1_c1+p1_c2+p1_c3+p1_c4+p1_c5+p1_c6+p1_c7+ # All gamestate information
          p2_c0+p2_c1+p2_c2+p2_c3+p2_c4+p2_c5+p2_c6+p2_c7+
          p1_wins+
         p2_wins+
         p1_general+p2_general+
         #p1_spy+p2_spy+
         p1_holds+p2_holds, data = card_viability)

spy_wf = workflow() %>%
  add_recipe(spy_recipe) %>%
  add_model(tree_mod)

spy_fit <- spy_wf %>% fit(card_viability %>% filter(p1_card==card_of_interest))

tree_fitted <- spy_fit %>% 
  extract_fit_parsnip()

tree_fitted

rpart.plot(tree_fitted$fit)
```

For card 7 (Prince)

```{r}
card_of_interest = 7 # Doing each card's tree 1 at a time

tree_mod <- decision_tree(mode = "classification", tree_depth = 4, cost_complexity = double(1)) %>%
  set_engine("rpart") %>%
  set_mode("classification")

spy_recipe = recipe(p1_card_viable ~ #p1_c0+p1_c1+p1_c2+p1_c3+p1_c4+p1_c5+p1_c6+p1_c7+ # All gamestate information
          p2_c0+p2_c1+p2_c2+p2_c3+p2_c4+p2_c5+p2_c6+p2_c7+
          p1_wins+
         p2_wins+
         p1_general+p2_general+
         #p1_spy+p2_spy+
         p1_holds+p2_holds, data = card_viability)

spy_wf = workflow() %>%
  add_recipe(spy_recipe) %>%
  add_model(tree_mod)

spy_fit <- spy_wf %>% fit(card_viability %>% filter(p1_card==card_of_interest))

tree_fitted <- spy_fit %>% 
  extract_fit_parsnip()

tree_fitted

rpart.plot(tree_fitted$fit)
  
```

# Human conformity to optimal

In this section, we're looking at every card a player had the option to play, the optimal probability to play it, and whether they played it.



## Absolute mistakes

"Absolute mistake" = playing a card with optimal probability of 0. These plays are against theory, but may still be beneficial if you have a confident prediction about your opponent's choice.

Which cards are most often played when they shouldn't have?

### Mistakes in non-spy turns

Counts of all absolute mistakes made by card

```{r}
# Overall 
played_vs_optimal %>% 
  #filter(this_card_played == 1) %>% 
  mutate(is_viable = ifelse(optimal_prob == 0, "Not Viable", "Viable")) %>% 
  group_by(is_viable, this_card_played) %>% 
  summarize(n = n()) %>% 
  pivot_wider(names_from = is_viable, values_from = n) %>% 
  mutate(viability_rate = Viable / (Viable + `Not Viable`))

# By turn
played_vs_optimal %>% 
  filter(this_card_played == 1) %>% 
  mutate(is_viable = ifelse(optimal_prob == 0, "Not Viable", "Viable")) %>% 
  group_by(is_viable, turn) %>% 
  summarize(n = n()) %>% 
  pivot_wider(names_from = is_viable, values_from = n) %>% 
  mutate(viability_rate = Viable / (Viable + `Not Viable`))

# By turn type
played_vs_optimal %>% 
  filter(this_card_played == 1) %>% 
  mutate(is_viable = ifelse(optimal_prob == 0, "Not Viable", "Viable")) %>% 
  group_by(is_viable, turn_type) %>% 
  summarize(n = n()) %>% 
  pivot_wider(names_from = is_viable, values_from = n) %>% 
  mutate(viability_rate = Viable / (Viable + `Not Viable`))

# By turn type and turn
played_vs_optimal %>% 
  filter(this_card_played == 1) %>% 
  mutate(is_viable = ifelse(optimal_prob == 0, "Not Viable", "Viable")) %>% 
  group_by(is_viable, turn_type, turn) %>% 
  summarize(n = n()) %>% 
  pivot_wider(names_from = is_viable, values_from = n) %>% 
  mutate(viability_rate = Viable / (Viable + `Not Viable`)) %>% 
  arrange(turn_type, turn)
```

When only 1 card is viable?

```{r}

# Overall
played_vs_optimal %>% 
  filter(optimal_prob == 1) %>% 
  mutate(card_played = ifelse(this_card_played == 1, "Played", "Not Played")) %>% 
  group_by(card_played, turn_type) %>% 
  summarize(n = n()) %>% 
  pivot_wider(names_from = card_played, values_from = n) %>% 
  mutate(accuracy = Played/(Played + `Not Played`))

# By turn
played_vs_optimal %>% 
  filter(optimal_prob == 1) %>% 
  mutate(card_played = ifelse(this_card_played == 1, "Played", "Not Played"),
         turn_type = ifelse(p1_spy, "Going Second", ifelse(p2_spy, "Going first", "Simultaneous"))) %>% 
  group_by(card_played, turn_type, turn) %>% 
  summarize(n = n()) %>% 
  pivot_wider(names_from = card_played, values_from = n) %>% 
  mutate(accuracy = Played/(Played + `Not Played`)) %>% 
  arrange(turn_type, turn)
```

```{r}
# Ad-hoc: what are the turn-2 simultaneus moves with a 100% best choice?
# If you play general into ambassador first turn, wizard into assassin is a pure play 
played_vs_optimal %>% 
  filter(optimal_prob == 1) %>% 
  mutate(card_played = ifelse(this_card_played == 1, "Played", "Not Played"),
         turn_type = ifelse(p1_spy, "Going Second", ifelse(p2_spy, "Going first", "Simultaneous"))) %>% 
  filter(turn_type == "Simultaneous", turn == 2)
```


```{r}
played_vs_optimal %>% 
  filter(p1_spy == FALSE & p2_spy == FALSE, optimal_prob == 0, this_card_played == 1) %>% 
  group_by(this_card) %>% #, turn
  summarise(n_mistakes = n())
```

Turn-by-turn view: Column = card, row = turn of game. The most common "absolute mistakes" are playing the 6 card on turn 1, the 0 card on turn 3, and the 1 card on turn 5.

```{r}
played_vs_optimal %>% 
  filter(p1_spy == FALSE & p2_spy == FALSE, optimal_prob == 0, this_card_played == 1) %>% 
  group_by(this_card, turn) %>% #
  summarise(n_mistakes = n()) %>% 
  pivot_wider(names_from = this_card, values_from = n_mistakes, id_cols = turn)
```

### Spy turns

####When going first (opponent used spy):

```{r}
# Overall
played_vs_optimal %>% 
  filter(p1_spy == FALSE & p2_spy == TRUE, optimal_prob == 0, this_card_played == 1) %>% 
  group_by(this_card) %>% #, turn
  summarise(n_mistakes = n())


# Turn by turn
played_vs_optimal %>% 
  filter(p1_spy == FALSE & p2_spy == TRUE, optimal_prob == 0, this_card_played == 1) %>% 
  group_by(this_card, turn) %>% #
  summarise(n_mistakes = n()) %>% 
  pivot_wider(names_from = this_card, values_from = n_mistakes, id_cols = turn)
```

What should've been played instead? (by turn)

```{r}
# Turn by turn
played_vs_optimal %>% 
  filter(p1_spy == FALSE & p2_spy == TRUE, optimal_prob > 0, this_card_played == 0) %>% 
  group_by(this_card, turn) %>% #
  summarise(n_mistakes = n()) %>% 
  pivot_wider(names_from = this_card, values_from = n_mistakes, id_cols = turn)
```

Actual card vs. optimal card/cards

```{r}
played_vs_optimal %>% 
  filter(turn==3) %>% 
  filter(p1_spy == FALSE & p2_spy == TRUE, optimal_prob > 0, this_card_played == 0) %>% 
  group_by(this_card, actual_card_played) %>% #
  summarise(n_mistakes = n()) %>% 
  pivot_wider(names_from = this_card, values_from = n_mistakes, id_cols = actual_card_played) %>% 
  arrange(actual_card_played)
```

#### When going second (opponent used spy)

```{r}
# Overall
played_vs_optimal %>% 
  filter(p1_spy == TRUE & p2_spy == FALSE, optimal_prob == 0, this_card_played == 1) %>% 
  group_by(this_card) %>% #, turn
  summarise(n_mistakes = n())


# Turn by turn
played_vs_optimal %>% 
  filter(p1_spy == TRUE & p2_spy == FALSE, optimal_prob == 0, this_card_played == 1) %>% 
  group_by(this_card, turn) %>% #
  summarise(n_mistakes = n()) %>% 
  pivot_wider(names_from = this_card, values_from = n_mistakes, id_cols = turn)
```

What should've been played instead? (by turn)

```{r}
# Turn by turn
played_vs_optimal %>% 
  filter(p1_spy == TRUE & p2_spy == FALSE, optimal_prob > 0, this_card_played == 0) %>% 
  group_by(this_card, turn) %>% #
  summarise(n_mistakes = n()) %>% 
  pivot_wider(names_from = this_card, values_from = n_mistakes, id_cols = turn)
```

Actual card vs. optimal card/cards

```{r}
played_vs_optimal %>% 
  filter(turn==3) %>% 
  filter(p1_spy == TRUE & p2_spy == FALSE, optimal_prob > 0, this_card_played == 0) %>% 
  group_by(this_card, actual_card_played) %>% #
  summarise(n_mistakes = n()) %>% 
  pivot_wider(names_from = this_card, values_from = n_mistakes, id_cols = actual_card_played) %>% 
  arrange(actual_card_played)
```

#### Looking at specific error turns

Change the filters here to see the type of turn you want

```{r }
played_vs_optimal %>% 
  filter(this_card == 4) %>% #, turn == 2) %>% # Edit this
  filter(p1_spy == TRUE & p2_spy == FALSE, optimal_prob > 0, this_card_played == 0) 
  

allTurns %>% filter(gamestate_str == 'p1-0134567-p2-0123567-w-02-g-00-s-10-h-00')
```

## Error rates by player

#### Non-spy turns

```{r}

played_vs_optimal %>% 
  filter(this_card_played == 1, !is.na(optimal_prob)) %>% 
  filter(p1_spy == FALSE & p2_spy == FALSE) %>% 
  mutate(absolute_mistake = if_else(this_card_played == 1 & optimal_prob == 0, 1, 0)) %>% 
  group_by(p1_name) %>% 
  summarize(total_mistakes = sum(absolute_mistake),
            total_plays = n(),
            mistake_ratio = mean(absolute_mistake)) %>% 
  arrange(-total_plays)
```

#### Spy turns

Spy turn errors p1_spy = p1 used spy, so p2 chooses second p2_spy = p2 used spy, so p2 chooses first

```{r}

# Pivot to a longer form with player_spied describing which player was spied
played_vs_optimal %>% 
  filter(this_card_played == 1, !is.na(optimal_prob)) %>% 
  filter(p1_spy == TRUE | p2_spy == TRUE) %>% 
  pivot_longer(c(p1_spy, p2_spy), names_to = "player_spied") %>% 
  filter(value == TRUE) %>% select(-value) %>%
  mutate(absolute_mistake = if_else(this_card_played == 1 & optimal_prob == 0, 1, 0)) %>% 
  group_by(p1_name, player_spied) %>% 
  summarize(total_mistakes = sum(absolute_mistake),
            total_plays = n(),
            mistake_ratio = mean(absolute_mistake)) %>% 
  arrange(-total_plays, player_spied) %>% head()
  
```

## Non-absolute errors

### First turn table

```{r}
played_vs_optimal %>%
  filter(turn == 1, this_card_played == 1) %>% 
  group_by(this_card) %>% 
  summarize(n_plays = n(),
            optimal_prob = mean(optimal_prob)) %>% 
  mutate(observed_prob = n_plays / sum(n_plays),
         expected_plays = optimal_prob * sum(n_plays)) %>% 
  kable(digits = 3)
```


#### Overall proportions played by bucket.

Here, we put a player's options into "buckets" based on how often they should optimally play it.

It's less difficult than anticipated to detect these differences, with players playing cards in the "0%" bucket \~10% of the time there's an opportunity to do so. They only play cards in the "100%" bucket 57% of the time. I've included the "bias_proportion" variable as the difference between the proportion played and center of the bucket. The lowest 2 buckets are over-played an the rest are under-played (more severely as the probability increases).

```{r}
prob_buckets <- played_vs_optimal %>% 
  #filter(optimal_prob > 0) %>% 
  #filter(p1_spy == FALSE & p2_spy == FALSE) %>% 
  mutate(prob_bucket = ceiling(optimal_prob*10)/10) %>% 
  group_by(prob_bucket) %>% 
  summarise(n_played = sum(this_card_played),
            n_opportunities = n(),
            prop_played = mean(this_card_played),
            avg_prop_in_bucket = mean(optimal_prob)) %>% 
  mutate(bias_proportion = prop_played - avg_prop_in_bucket,
            expected_plays = avg_prop_in_bucket * n_opportunities)

prob_buckets %>% 
  kable(digits = 2)

prob_buckets%>% 
  ggplot(aes(x = avg_prop_in_bucket, y = prop_played, size = n_opportunities)) +
  geom_point(stat = "identity")  +
  geom_abline(intercept = 0, slope = 1, color = "red") +
  scale_x_continuous(limits = c(0, 1), expand = expansion(add = c(0.01,0.01))) +
  scale_y_continuous(limits = c(0, 1), expand = expansion(add = c(0,0))) +
  labs(title = "Observed cards played vs. optimal probabilities (bucketed)",
       #subtitle = "",
       x = "Average poportion vs. optimal proportion",
       y = "% played")  +
  theme_bw() +
  theme(
    # Remove the y-axis
    axis.title.y = element_blank(),
    axis.text.y = element_blank(),
    # Set x-axis breaks from 0 to 7
    #axis.ticks.x = element_line(),
    #axis.text.x = element_text(size = 10),
    axis.ticks.length.x = unit(0, "cm") # Adjust tick length if needed
  )
```

```{r}

```


Separated by card

```{r}
prob_buckets_by_card <- played_vs_optimal %>% 
  mutate(prob_bucket = if_else(optimal_prob == 0 | optimal_prob == 1, optimal_prob, round(optimal_prob*9)/9)) %>% 
  group_by(prob_bucket, this_card) %>% 
  summarise(n_played = sum(this_card_played),
            n_opportunities = n(),
            prop_played = mean(this_card_played),
            avg_prop_in_bucket = mean(optimal_prob)) 

prob_buckets_by_card %>% 
  arrange(this_card)

prob_buckets_by_card %>% 
  ggplot(aes(x = prob_bucket, y = prop_played)) +
  geom_bar(stat = "identity") +
  facet_grid(rows = vars(this_card))
  
```

### Impact of errors

When a player makes an "error" how does that affect their "win probability"? Are some players making "errors" that are really beneficial predictions of their opponent's move?

```{r}

value_changes <- joined_human_ai %>% 
  group_by(Game, p1_name) %>% 
   # next_turn_value is the value of the next turn. If game is lost, use game outcome
  mutate(next_turn_value = if_else(Turn != max(Turn), lead(value, n=1),
                                if_else(Outcome == "Win", 1, if_else(Outcome == "Loss", 0, 0.5))),
         value_change = next_turn_value - value) %>% 
  left_join(played_vs_optimal %>% filter(this_card_played == 1))
  
# This plot is "Optimal probability of playing the card that was played" vs "change in value of game".
value_changes %>% 
  filter(optimal_prob > 0) %>% 
  ggplot(aes(x = optimal_prob, y = value_change)) +
  geom_point(aes(color = factor(P1)), alpha = 0.5) +
  geom_smooth(color = "black") +
  scale_color_brewer(palette = "Set1") +
  labs(title = "Observed Value Changes vs. Optimal Probabilities in viable plays",
       color = "Card Played",
       y = "Value Change",
       x = "MiniMax Probability of Card Played")
```

```{r}
value_changes %>% 
  #filter(p1_spy == FALSE & p2_spy == FALSE) %>% 
  mutate(abs_mistake = if_else(optimal_prob == 0, "Mistake", "Non-mistake")) %>% 
  group_by(abs_mistake) %>% 
  summarize(avg_change = mean(value_change), 
            std_dev = sd(value_change),
            n = n())

# t-test on difference (non-spy)
SE = (0.2362542/239 + 0.2356995/797)^0.5
t = (-0.028737909 - 0.008617767)/ SE
df = 239 + 797 - 2

pt(t, df=df, lower.tail=TRUE)

# t-test on difference (including spy turns)
SE = (0.2104452/369 + 0.2239661/905)^0.5
t = (-0.04017535 - 0.01638089)/ SE
df = 369 + 905 - 2

pt(t, df=df, lower.tail=TRUE)
```

There appears to be a small, but statistically insignificant difference between the value changes from plays that are "miastakes" vs. non-mistakes.

### Do some cards tend to increase value?

```{r}
value_changes %>% 
  filter(p1_spy == FALSE & p2_spy == FALSE) %>% 
  #mutate(abs_mistake = if_else(optimal_prob == 0, "Mistake", "Non-mistake")) %>% 
  group_by(P1) %>% 
  summarize(avg_change = mean(value_change), 
            std_dev = sd(value_change),
            n = n())
```

# Human EDA

```{r}
joined_human_ai %>% filter(is.na(value)) %>% 
  select(c(paste("p1_c", 0:7, sep=''), paste("p2_c", 0:7, sep=''), 
                                                "p1_wins", "p2_wins", "p1_holds", "p2_holds",
                                                "p1_spy", "p2_spy", "p1_general", "p2_general", "Turn", "Game"))
```

```{r}
allTurns %>% filter(turn==5, p1_holds==2, p2_holds==2)
```

```{r}
joined_human_ai %>% 
  filter(Game==1)
```

### Game plots

```{r}
joined_human_ai %>% 
  mutate(game_player = str_c("Game",Game,p1_name)) %>% 
  ggplot(aes(x = turn, y = value, color=Outcome, group = game_player)) +
  geom_line(alpha = 0.5) +
  facet_grid(rows = vars(Outcome))
```

```{r}
joined_human_ai %>% filter(value==1, Outcome=="Loss")# %>% select()
```



Number of cards played and turns

```{r}
joined_human_ai %>% summarize(n = n(), n_turns = n()/2)
```

### Turns per game

```{r}
turns_per_game <- joined_human_ai %>% 
  group_by(Game) %>% 
  summarize(turns = max(turn)) 

n_games <- nrow(turns_per_game)

hist(turns_per_game$turns)

joined_human_ai %>% 
  filter(Flipped == FALSE) %>% 
  ggplot(aes(x=turn)) +
  geom_bar(fill = 'white', color = "black", size = 1) +
  geom_text(aes(label = ..count..), 
            stat = 'count', 
            vjust = -0.5,  # Vertical adjustment for count
            color = 'black') +
  geom_text(aes(label = scales::percent(..count.. / n_games, accuracy = 0.1)), 
            stat = 'count', 
            vjust = 1.5,  # Vertical adjustment for proportion
            color = 'black') +
  labs(title = "Observed Plays by Turn of Game",
       subtitle = "Count and % of games that reach turn x",
       x = "Turn",
       y = "Games")  +
  theme_minimal() +
  theme(
    # Remove the y-axis
    axis.title.y = element_blank(),
    axis.text.y = element_blank(),
    # Remove grid lines
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    # Set x-axis breaks from 0 to 7
    axis.ticks.x = element_line(),
    axis.text.x = element_text(size = 10),
    axis.ticks.length.x = unit(0, "cm"),  # Adjust tick length if needed
  ) +
  scale_x_continuous(breaks = 1:8) +
  scale_y_continuous(expand = expansion(add = c(0,10)))

mean(turns_per_game$turns)

```


Distinct Game States

```{r}
joined_human_ai %>% 
  distinct(gamestate_str)
```

# Human first turn dependence analysis

Count of games by player

```{r}
player_game_counts <- joined_human_ai %>% 
  filter(turn==1) %>% 
  group_by(p1_name) %>% 
  summarize(n = n()) %>%
  arrange(desc(n))

frequent_players <- player_game_counts %>% 
  filter(n > 20) %>% 
  pull(p1_name)

frequent_players
```

```{r}
first_card_relationships <- joined_human_ai %>% 
  filter(turn == 1, p1_name %in% frequent_players) %>% 
  group_by(p1_name) %>% 
  arrange(Game, Turn) %>% 
  mutate(previous_game_first_card = lag(P1, 1)) %>%
  rename(first_card = P1) %>% 
  ungroup() %>% 
  filter(!is.na(previous_game_first_card)) %>% 
  group_by(previous_game_first_card, first_card, p1_name) %>% 
  summarize(n = n())

first_card_relationships %>% 
  pivot_wider(names_from = first_card, values_from = n) %>% 
  arrange(p1_name) %>% 
  select(previous_game_first_card, p1_name, `0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`)

first_card_relationships %>% 
  group_by(p1_name) %>% 
  mutate(prop = n/sum(n)) %>% 
  ggplot(aes(x = previous_game_first_card, y = first_card)) +
  geom_tile(aes(fill = prop)) +
  geom_text(aes(label = n)) +
  facet_grid(rows = ~p1_name, scales = "free")
```

