---
title: "BraveRatsThesis"
code-fold: true
self-contained: true
format:
  html:
    toc: true
editor: visual
---

# Setup

allTurns = optimal gameplay data
braverats = human data

```{r packages-setup}
#| warning: false

library(tidyverse)
library(tidyclust)
library(tclust)
library(tidymodels)
library(knitr)
```

## Nash optimal data

```{r import-optimal}
# Main data
# Previous filename: "SolutionFiles/optimalSolutionNew.txt"

allTurns <- read.csv("SolutionFiles/updatedOptimalSolution.txt", header = FALSE, sep = "|", col.names = c("gamestate", "value", "s1_type","p1_optimal","s2_type", "p2_optimal", ".m", "value_matrix")) %>% 
  mutate(gamestate = substr(gamestate,1, nchar(gamestate)-2)) %>%
  mutate(gamestate_str = gamestate) %>% #Making a copy to be used as row labels
  separate(gamestate, c(".1", "p1_cards", ".2", "p2_cards", ".3", "wins", ".4", "generals", ".5", "spies", ".6", "holds"), sep = "-")

rownames(allTurns) <- allTurns$gamestate_str
allTurns <- allTurns %>% 
  separate(p1_optimal, paste("p1_o", 0:7, sep=''), sep=",", convert = TRUE) %>% 
  separate(p2_optimal, paste("p2_o", 0:7, sep=''), sep=",", convert = TRUE)

allTurns <- allTurns %>% select(-starts_with(".")) # get rid of temp columns starting with "."
allTurns <- allTurns %>% mutate(cards_left = nchar(p1_cards),
                                turn = 9-cards_left) %>% 
  mutate(p1_c0 = grepl("0",p1_cards),
          p1_c1 = grepl("1",p1_cards),
          p1_c2 = grepl("2",p1_cards),
          p1_c3 = grepl("3",p1_cards),
          p1_c4 = grepl("4",p1_cards),
          p1_c5 = grepl("5",p1_cards),
          p1_c6 = grepl("6",p1_cards),
          p1_c7 = grepl("7",p1_cards),
          p2_c0 = grepl("0",p2_cards),
          p2_c1 = grepl("1",p2_cards),
          p2_c2 = grepl("2",p2_cards),
          p2_c3 = grepl("3",p2_cards),
          p2_c4 = grepl("4",p2_cards),
          p2_c5 = grepl("5",p2_cards),
          p2_c6 = grepl("6",p2_cards),
          p2_c7 = grepl("7",p2_cards),
          p1_wins = as.numeric(substring(wins, 1,1)),
         p2_wins = as.numeric(substring(wins, 2,2)),
         p1_general = substring(generals, 1,1)==1,
         p2_general = substring(generals, 2,2)==1,
         p1_spy = substring(spies, 1,1)==1,
         p2_spy = substring(spies,2,2)==1,
         p1_holds = as.numeric(substring(holds,1,1)),
         p2_holds = as.numeric(substring(holds,2,2))
         )

# For response turns, we have a separate distribution of (equal) probabilities for each opponent's choice
response_turns <- allTurns %>% 
  filter(s1_type == "s1r") %>% 
  # Each "optimal" here is whether 
  pivot_longer(cols = c("p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7"), names_to = "responding_to_card", values_to = "optimal_responses") %>% 
  mutate(responding_to_card = as.numeric(substring(responding_to_card,5,6))) %>% 
  filter(optimal_responses!="") %>% # Cards opponent doesn't have have "" optimal strings
  mutate(num_possibilities = str_length(optimal_responses),
         p1_o0 = ifelse(p1_c0, ifelse(grepl("0",optimal_responses), 1/num_possibilities, 0), NA),
         p1_o1 = ifelse(p1_c1, ifelse(grepl("1",optimal_responses), 1/num_possibilities, 0), NA),
         p1_o2 = ifelse(p1_c2, ifelse(grepl("2",optimal_responses), 1/num_possibilities, 0), NA),
         p1_o3 = ifelse(p1_c3, ifelse(grepl("3",optimal_responses), 1/num_possibilities, 0), NA),
         p1_o4 = ifelse(p1_c4, ifelse(grepl("4",optimal_responses), 1/num_possibilities, 0), NA),
         p1_o5 = ifelse(p1_c5, ifelse(grepl("5",optimal_responses), 1/num_possibilities, 0), NA),
         p1_o6 = ifelse(p1_c6, ifelse(grepl("6",optimal_responses), 1/num_possibilities, 0), NA),
         p1_o7 = ifelse(p1_c7, ifelse(grepl("7",optimal_responses), 1/num_possibilities, 0), NA)
  ) %>% 
  select(-num_possibilities, -optimal_responses)

normal_turns <- allTurns %>% 
  filter(s1_type != "s1r") %>% 
  mutate(responding_to_card = NA) # This indicates that this entry is not a response to an opponent's spied card



allOptimalStrategies <- rbind(normal_turns, response_turns) %>% 
  mutate(across(matches("^P[12]_o"), ~as.numeric(.))) # Turn all "optimal probability" to numeric

# Saving Memory
remove(response_turns)
remove(normal_turns)

# Lists of optimal strategy columns
# c("p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7")
# c("p2_o0","p2_o1","p2_o2","p2_o3","p2_o4","p2_o5","p2_o6","p2_o7")
```

```{r}
# A dataframe of just the optimal probabilities (0 for non-possibilities)
# Used for clustering later

p1_optimal_turns <- allOptimalStrategies %>% 
  #filter(turn <=5) %>% 
  filter(p1_spy == 0 & p2_spy == 0) %>% 
  select("p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7") %>% 
  mutate_all(~replace(., is.na(.), 0))
```

## Human data

```{r read-human-data}
#braverats <- read.csv("BraveRatsData.csv")
source("readHumanData.r")
```

```{r human-joined-ai}
joined_human_ai <- braverats %>% left_join(allOptimalStrategies, by=c(paste("p1_c", 0:7, sep=''), paste("p2_c", 0:7, sep=''), 
                                                "p1_wins", "p2_wins", "p1_holds", "p2_holds",
                                                "p1_spy", "p2_spy", "p1_general", "p2_general", "responding_to_card"))
```

# EDA

## Number of turns

Number of (non-terminal) states for each turn of game

```{r}
allTurns %>% 
  ggplot(aes(x = turn)) +
  geom_histogram()

allTurns %>% 
  group_by(turn) %>% 
  summarize(count = n())
```

Distinct strategies by turn (counting multiple strategies on spy turns)

```{r}
allOptimalStrategies %>% 
  ggplot(aes(x = turn)) +
  geom_histogram()

allOptimalStrategies %>% 
  group_by(turn) %>% 
  summarize(count = n())
```

## Values of the turns

```{r}
hist(allTurns$value)
```

Plots of value by turn

```{r}
allTurns %>% 
  ggplot(aes(x = factor(turn), y = value)) +
  geom_violin()

allTurns %>% 
  ggplot(aes(x = factor(turn), y = value)) +
  geom_point(alpha = 0.05)

allTurns %>% 
  ggplot(aes(x = value)) +
  geom_histogram() +
  facet_grid(rows = vars(turn), scales = "free_y")
```

For each card, the distribution of what its optimal probability is when it's an option.

```{r}
card_optimals <- allOptimalStrategies %>% 
  pivot_longer(cols = c("p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7"), names_prefix="p1_o", names_to = "card", values_to = "optimal_prob") %>% 
  filter(!is.na(optimal_prob))

card_optimals %>% 
  filter(spies == "00") %>% 
  ggplot(aes(x = optimal_prob)) +
  geom_histogram(bins = 10) +
  facet_grid(rows = vars(card))
```

Average of each card, by turn

```{r}
card_optimals %>% 
  filter(spies == "00") %>% 
  select(card,turn,optimal_prob) %>% 
  filter(!is.na(optimal_prob)) %>% 
  group_by(card,turn) %>% 
  summarize(avg_prob = mean(optimal_prob)) %>% 
  ggplot(aes(x = turn, y = avg_prob, color = card)) +
  geom_line()
  
```

# Clustering

```{r}
k <- 12
kmeans_spec <- k_means(num_clusters=k)

kmeans_fit <- kmeans_spec %>% fit(~p1_o0+p1_o1+p1_o2+p1_o3+p1_o4+p1_o5+p1_o6+p1_o7,data = p1_optimal_turns)

kmeans_fit$fit$tot.withinss
kmeans_fit$fit$betweenss

df_clusters <- kmeans_fit$fit$centers %>% 
  data.frame() %>% mutate(cluster_num = 1:k) %>% 
  pivot_longer(cols = c("p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7"), names_prefix="p1_o", names_to = "card", values_to = "optimal_prob") 

df_clusters %>% 
  ggplot(aes(x = card, y = optimal_prob)) +
  geom_bar(stat = "identity") +
  facet_grid(rows = vars(cluster_num))
```

```{r cluster-descriptions}
# Total number of turns in each cluster
cluster_info <- allOptimalStrategies %>% 
  #filter(turn <=5) %>% 
  filter(p1_spy == 0 & p2_spy == 0) %>% 
  mutate(cluster = kmeans_fit$fit$cluster)

cluster_info %>% group_by(cluster) %>% 
  summarize(n = n()) %>% 
  mutate(prop = n/sum(n))
```

## Optimal data for each cluster

```{r}
# What turns are this particular cluster in?

cluster_info %>%
  group_by(turn, cluster) %>% 
  summarize(count = n()) %>% 
  pivot_wider(names_from ="turn", names_prefix="Turn_", values_from=count, id_cols=cluster)

# How are the optimal probabilities distributed in real turns an example cluster?
# TRY TO ADD CENTROIDS TO THIS
df_cluster_probs <- cluster_info %>% 
  filter(cluster==3) %>% 
  pivot_longer(cols = c("p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7"),
               names_prefix="p1_o", names_to = "card", values_to = "optimal_prob") %>% 
  filter(!is.na(optimal_prob)) %>% 
  select(card, optimal_prob) 

df_cluster_probs %>% 
  ggplot(aes(x = optimal_prob)) +
  geom_histogram(bins = 10) +
  facet_grid(rows = vars(card))
```

**Human data counts in each cluster**

```{r, waring=FALSE}
# Joining human data with clusters
human_clusters <- braverats %>% left_join(cluster_info, by=c(paste("p1_c", 0:7, sep=''), paste("p2_c", 0:7, sep=''), 
                                                "p1_wins", "p2_wins", "p1_holds", "p2_holds",
                                                "p1_spy", "p2_spy", "p1_general", "p2_general"))

# Overall counts and props

human_clusters %>% group_by(cluster) %>% 
  summarize(n = n()) %>% 
  mutate(prop = n/sum(n)) %>% 
  arrange(desc(n))

# By person counts and props

human_clusters %>% group_by(cluster, p1_name) %>% 
  summarize(n = n()) %>% 
  group_by(p1_name) %>% 
  mutate(prop_for_player = n/sum(n)) %>% 
  arrange(desc(n))
```

```{r}
# What turns are each cluster in for humans?

human_clusters %>%
  group_by(turn, cluster) %>% 
  summarize(count = n()) %>% 
  pivot_wider(names_from ="turn", names_prefix="Turn_", values_from=count, id_cols=cluster)

# How are the optimal probabilities distributed in real turns from this cluster?
human_clusters %>% 
  pivot_longer(cols = c("p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7"),
               names_prefix="p1_o", names_to = "card", values_to = "optimal_prob") %>% 
  ggplot(aes(x = optimal_prob)) +
  geom_histogram(bins = 10) +
  facet_grid(rows = vars(card))
```

# Regression

(This task may be better to do in Python actually? Looking into GLM to do the transformation.)

```{r}
df_predictors <- allOptimalStrategies %>% 
  #filter(p1_spy==0, p2_spy==0) %>% 
  select(
  p1_o0,p1_o1,p1_o2,p1_o3,p1_o4,p1_o5,p1_o6,p1_o7, value, turn, #Outputs
  p1_c0,p1_c1,p1_c2,p1_c3,p1_c4,p1_c5,p1_c6,p1_c7, #Inputs
          p2_c0,p2_c1,p2_c2,p2_c3,p2_c4,p2_c5,p2_c6,p2_c7,
          p1_wins,
         p2_wins,
         p1_general,p2_general,
         p1_spy,p2_spy,
         p1_holds,p2_holds) %>% 
  mutate_all(~replace(., is.na(.), 0))

#lin_reg_spec <- logistic_reg() %>%
  #set_mode("regression") %>%
#  set_engine("lm")

#ins_lm_fit <- lin_reg_spec %>%
#  fit(p1_o7 ~ p1_c0+p1_c1+p1_c2+p1_c3+p1_c4+p1_c5+p1_c6+p1_c7+ #Inputs
#          p2_c0+p2_c1+p2_c2+p2_c3+p2_c4+p2_c5+p2_c6+p2_c7+
#          p1_wins+
#         p2_wins+
#         p1_general+p2_general+
#         #p1_spy+p2_spy+
#         p1_holds+p2_holds, data = df_predictors) 
#
#ins_lm_fit$fit$coefficients
```

## Regression to find value (win probability)

Model 1: All predictors, linear regression

```{r}
lin_reg_spec <- linear_reg() %>%
  set_mode("regression") %>%
  set_engine("lm")

value_lm_fit <- lin_reg_spec %>%
  fit(value ~ p1_c0+p1_c1+p1_c2+p1_c3+p1_c4+p1_c5+p1_c6+p1_c7+ #Inputs
          p2_c0+p2_c1+p2_c2+p2_c3+p2_c4+p2_c5+p2_c6+p2_c7+
          p1_wins+
         p2_wins+
         p1_general+p2_general+
         p1_spy+p2_spy+
         p1_holds+p2_holds, data = df_predictors) 

value_lm_fit$fit$coefficients %>% round(4)
```

Model 2: Only P1's factors, linear regression

```{r}
lin_reg_spec <- linear_reg() %>%
  set_mode("regression") %>%
  set_engine("lm")

value_lm_fit_2 <- lin_reg_spec %>%
  fit(value ~ p1_c0+p1_c1+p1_c2+p1_c3+p1_c4+p1_c5+p1_c6+p1_c7+ #Inputs
          #p2_c0+p2_c1+p2_c2+p2_c3+p2_c4+p2_c5+p2_c6+p2_c7+
          p1_wins+
         #p2_wins+
         p1_general+#p2_general+
         p1_spy+#p2_spy+
         p1_holds#+p2_holds
      , data = df_predictors) 

value_lm_fit_2$fit$coefficients %>% round(4)
```

Model 3: Only P1's factors \* turn, linear regression

```{r}
lin_reg_spec <- linear_reg() %>%
  set_mode("regression") %>%
  set_engine("lm")

value_lm_fit_3 <- lin_reg_spec %>%
  fit(value ~ (p1_c0+p1_c1+p1_c2+p1_c3+p1_c4+p1_c5+p1_c6+p1_c7+ #Inputs
          #p2_c0+p2_c1+p2_c2+p2_c3+p2_c4+p2_c5+p2_c6+p2_c7+
          p1_wins+
         #p2_wins+
         p1_general+#p2_general+
         p1_spy+#p2_spy+
         p1_holds#+p2_holds)
  ):turn + turn
      , data = df_predictors %>% mutate(turn = factor(turn))) 

fit_df <- value_lm_fit_3$fit$coefficients %>% round(4) %>% data.frame() 
fit_df <- fit_df %>% mutate(predictor = rownames(fit_df)) %>% separate(predictor, sep = ":", into = c("var", "turn"))
fit_df[1:8,]
fit_df[-(1:8),] %>% 
  pivot_wider(names_from = turn, values_from = ".")
```

### GLM

Model 4: Only P1's factors, logistic curve

```{r}
glm_1 <- glm(value ~ p1_c0+p1_c1+p1_c2+p1_c3+p1_c4+p1_c5+p1_c6+p1_c7+
          p1_wins+
         p1_general+
         p1_spy+
         p1_holds, family = quasibinomial(link="logit"), data = df_predictors)

summary(glm_1)

# Interpret these as "multipying the odds of winning"
exp(glm_1$coefficients)
```

Model 5: All factors, logit curve

```{r}
glm_1 <- glm(value ~ p1_c0+p1_c1+p1_c2+p1_c3+p1_c4+p1_c5+p1_c6+p1_c7+
          p1_wins+
         p1_general+
         p1_spy+
         p1_holds, family = quasibinomial(link="logit"), data = df_predictors)

summary(glm_1)

# Interpret these as "multipying the odds of winning"
exp(glm_1$coefficients)
```

```{r}
#| eval = FALSE
test_df <- data.frame()

predict(glm_1, )
```

**Overall, regression proves difficult to operationalize and interpret.**

# Spy turns

Given that card X is in hand and you've been spied, how often is card X optimal to play?

This table is split by turn of game. Contrary to prior belief, card 0 is not the overwhelming preferrence even when it's an option (\<50% until turn 5).

```{r}
allOptimalStrategies %>% 
  filter(p2_spy==1) %>% 
  group_by(turn) %>% 
  summarize(across(c("p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7"), ~mean(.x, na.rm=TRUE)))
```

A manual survey of what cards are optimal during different turns.

```{r}
spy_optimal_cards <- allOptimalStrategies %>% 
  filter(p2_spy==TRUE) %>% 
  #select(p1_cards, p2_cards, "p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7", "p2_o0","p2_o1","p2_o2","p2_o3","p2_o4","p2_o5","p2_o6","p2_o7") %>% 
  # Extracting the optimal card for each player
  pivot_longer(cols = c( "p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7"), names_to = "p1_card", values_to = "optimal_prob") %>% 
  filter(optimal_prob==1) %>% 
  mutate(p1_card=as.factor(substring(p1_card,5,6))) %>% 
  select(-optimal_prob) %>% 
  pivot_longer(cols = c("p2_o0","p2_o1","p2_o2","p2_o3","p2_o4","p2_o5","p2_o6","p2_o7"), names_to = "p2_card", values_to = "optimal_prob") %>% 
  filter(optimal_prob==1) %>% 
  mutate(p2_card=as.factor(substring(p2_card,5,6))) %>% 
  select(-optimal_prob)

spy_optimal_cards %>% 
  filter(turn<=3) %>% 
  select(p1_cards, p2_cards,wins, generals, holds, p1_card, p2_card) %>% 
  sample_n(10)
```

### Decision tree for spy turns

```{r}
library(rpart)

library(rpart.plot)


tree_mod <- decision_tree(mode = "classification", tree_depth = 3, cost_complexity = double(1)) %>%
  set_engine("rpart") %>%
  set_mode("classification")

spy_recipe = recipe(p1_card ~ #p1_c0+p1_c1+p1_c2+p1_c3+p1_c4+p1_c5+p1_c6+p1_c7+ # All gamestate information
          p2_c0+p2_c1+p2_c2+p2_c3+p2_c4+p2_c5+p2_c6+p2_c7+
          p1_wins+
         p2_wins+
         p1_general+p2_general+
         #p1_spy+p2_spy+
         p1_holds+p2_holds, data = spy_optimal_cards)

spy_wf = workflow() %>%
  add_recipe(spy_recipe) %>%
  add_model(tree_mod)

spy_fit <- spy_wf %>% fit(spy_optimal_cards)

tree_fitted <- spy_fit %>% 
  extract_fit_parsnip()

tree_fitted

rpart.plot(tree_fitted$fit)
```

# Analysis of viability

In this section I use decision trees to see how easy it is to tell whether a card is "viable" in a certain situation or not. A card is "viable" if the optimal probability to play it is above 0.

```{r}
# This dataset looks card-by-card whether each card is viable in a particular gamestate.
# The idea is that if it's simple to tell which cards are viable, we can more easily figure out the play patterns that will work

card_viability <- allOptimalStrategies %>% 
  filter(p2_spy==FALSE, turn <8) %>% 
  # Extracting the optimal card for each player
  pivot_longer(cols = c( "p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7"), names_to = "p1_card", values_to = "p1_optimal_prob") %>% 
  filter(!is.na(p1_optimal_prob)) %>% 
  mutate(p1_card=as.factor(substring(p1_card,5,6)),
         p1_card_viable = ifelse(p1_optimal_prob>0,"viable","not viable"))
  

# card_viability %>% sample_n(10)
```

We'll make a tree for each card (I'll just do a few for now to illustrate).

For card 0 (musician)

```{r}
card_of_interest = 0 # Doing each card's tree 1 at a time

tree_mod <- decision_tree(mode = "classification", tree_depth = 3, cost_complexity = double(1)) %>%
  set_engine("rpart") %>%
  set_mode("classification")

spy_recipe = recipe(p1_card_viable ~ #p1_c0+p1_c1+p1_c2+p1_c3+p1_c4+p1_c5+p1_c6+p1_c7+ # All gamestate information
          p2_c0+p2_c1+p2_c2+p2_c3+p2_c4+p2_c5+p2_c6+p2_c7+
          p1_wins+
         p2_wins+
         p1_general+p2_general+
         #p1_spy+p2_spy+
         p1_holds+p2_holds, data = card_viability)

spy_wf = workflow() %>%
  add_recipe(spy_recipe) %>%
  add_model(tree_mod)

spy_fit <- spy_wf %>% fit(card_viability %>% filter(p1_card==card_of_interest))

tree_fitted <- spy_fit %>% 
  extract_fit_parsnip()

tree_fitted

rpart.plot(tree_fitted$fit)
```

For princess (1)

```{r}
card_of_interest = 1 # Doing each card's tree 1 at a time

tree_mod <- decision_tree(mode = "classification", tree_depth = 4, cost_complexity = double(1)) %>%
  set_engine("rpart") %>%
  set_mode("classification")

spy_recipe = recipe(p1_card_viable ~ #p1_c0+p1_c1+p1_c2+p1_c3+p1_c4+p1_c5+p1_c6+p1_c7+ # All gamestate information
          p2_c0+p2_c1+p2_c2+p2_c3+p2_c4+p2_c5+p2_c6+p2_c7+
          p1_wins+
         p2_wins+
         p1_general+p2_general+
         #p1_spy+p2_spy+
         p1_holds+p2_holds, data = card_viability)

spy_wf = workflow() %>%
  add_recipe(spy_recipe) %>%
  add_model(tree_mod)

spy_fit <- spy_wf %>% fit(card_viability %>% filter(p1_card==card_of_interest))

tree_fitted <- spy_fit %>% 
  extract_fit_parsnip()

tree_fitted

rpart.plot(tree_fitted$fit)
```

For card 7 (Prince)

```{r}
card_of_interest = 7 # Doing each card's tree 1 at a time

tree_mod <- decision_tree(mode = "classification", tree_depth = 4, cost_complexity = double(1)) %>%
  set_engine("rpart") %>%
  set_mode("classification")

spy_recipe = recipe(p1_card_viable ~ #p1_c0+p1_c1+p1_c2+p1_c3+p1_c4+p1_c5+p1_c6+p1_c7+ # All gamestate information
          p2_c0+p2_c1+p2_c2+p2_c3+p2_c4+p2_c5+p2_c6+p2_c7+
          p1_wins+
         p2_wins+
         p1_general+p2_general+
         #p1_spy+p2_spy+
         p1_holds+p2_holds, data = card_viability)

spy_wf = workflow() %>%
  add_recipe(spy_recipe) %>%
  add_model(tree_mod)

spy_fit <- spy_wf %>% fit(card_viability %>% filter(p1_card==card_of_interest))

tree_fitted <- spy_fit %>% 
  extract_fit_parsnip()

tree_fitted

rpart.plot(tree_fitted$fit)
  
```

# Human conformity to optimal

In this section, we're looking at every card a player had the option to play, the optimal probability to play it, and whether they played it.

```{r}
#| label: player-optimal-data-reshaping

played_vs_optimal <- joined_human_ai %>% 
  pivot_longer(cols = c("p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7"), names_to = "card_untrimmed", values_to = "optimal_prob") %>%
  mutate(this_card = substring(card_untrimmed, 5,6),
         this_card_played = if_else(P1==this_card, 1, 0),
         actual_card_played = P1,
         turn_type = ifelse(p1_spy, "Going Second", ifelse(p2_spy, "Going first", "Simultaneous"))) %>% 
  select(Game, turn, p1_name, this_card, this_card_played, actual_card_played, optimal_prob, gamestate_str, p1_spy, p2_spy, turn_type) %>% 
  filter(!is.na(optimal_prob)) # Removing invalid cards

#played_vs_optimal %>% sample_n(8)
```

## Absolute mistakes

"Absolute mistake" = playing a card with optimal probability of 0. These plays are against theory, but may still be beneficial if you have a confident prediction about your opponent's choice.

Which cards are most often played when they shouldn't have?

### Mistakes in non-spy turns

Counts of all absolute mistakes made by card

```{r}
# Overall 
played_vs_optimal %>% 
  #filter(this_card_played == 1) %>% 
  mutate(is_viable = ifelse(optimal_prob == 0, "Not Viable", "Viable")) %>% 
  group_by(is_viable, this_card_played) %>% 
  summarize(n = n()) %>% 
  pivot_wider(names_from = is_viable, values_from = n) %>% 
  mutate(viability_rate = Viable / (Viable + `Not Viable`))

# By turn
played_vs_optimal %>% 
  filter(this_card_played == 1) %>% 
  mutate(is_viable = ifelse(optimal_prob == 0, "Not Viable", "Viable")) %>% 
  group_by(is_viable, turn) %>% 
  summarize(n = n()) %>% 
  pivot_wider(names_from = is_viable, values_from = n) %>% 
  mutate(viability_rate = Viable / (Viable + `Not Viable`))

# By turn type
played_vs_optimal %>% 
  filter(this_card_played == 1) %>% 
  mutate(is_viable = ifelse(optimal_prob == 0, "Not Viable", "Viable")) %>% 
  group_by(is_viable, turn_type) %>% 
  summarize(n = n()) %>% 
  pivot_wider(names_from = is_viable, values_from = n) %>% 
  mutate(viability_rate = Viable / (Viable + `Not Viable`))

# By turn type and turn
played_vs_optimal %>% 
  filter(this_card_played == 1) %>% 
  mutate(is_viable = ifelse(optimal_prob == 0, "Not Viable", "Viable")) %>% 
  group_by(is_viable, turn_type, turn) %>% 
  summarize(n = n()) %>% 
  pivot_wider(names_from = is_viable, values_from = n) %>% 
  mutate(viability_rate = Viable / (Viable + `Not Viable`)) %>% 
  arrange(turn_type, turn)
```

```{r}

```


When only 1 card is viable?

```{r}

# Overall
played_vs_optimal %>% 
  filter(optimal_prob == 1) %>% 
  mutate(card_played = ifelse(this_card_played == 1, "Played", "Not Played")) %>% 
  group_by(card_played, turn_type) %>% 
  summarize(n = n()) %>% 
  pivot_wider(names_from = card_played, values_from = n) %>% 
  mutate(accuracy = Played/(Played + `Not Played`))

# By turn
played_vs_optimal %>% 
  filter(optimal_prob == 1) %>% 
  mutate(card_played = ifelse(this_card_played == 1, "Played", "Not Played"),
         turn_type = ifelse(p1_spy, "Going Second", ifelse(p2_spy, "Going first", "Simultaneous"))) %>% 
  group_by(card_played, turn_type, turn) %>% 
  summarize(n = n()) %>% 
  pivot_wider(names_from = card_played, values_from = n) %>% 
  mutate(accuracy = Played/(Played + `Not Played`)) %>% 
  arrange(turn_type, turn)
```

```{r}
# Ad-hoc: what are the turn-2 simultaneus moves with a 100% best choice?
# If you play general into ambassador first turn, wizard into assassin is a pure play 
played_vs_optimal %>% 
  filter(optimal_prob == 1) %>% 
  mutate(card_played = ifelse(this_card_played == 1, "Played", "Not Played"),
         turn_type = ifelse(p1_spy, "Going Second", ifelse(p2_spy, "Going first", "Simultaneous"))) %>% 
  filter(turn_type == "Simultaneous", turn == 2)
```


```{r}
played_vs_optimal %>% 
  filter(p1_spy == FALSE & p2_spy == FALSE, optimal_prob == 0, this_card_played == 1) %>% 
  group_by(this_card) %>% #, turn
  summarise(n_mistakes = n())
```

Turn-by-turn view: Column = card, row = turn of game. The most common "absolute mistakes" are playing the 6 card on turn 1, the 0 card on turn 3, and the 1 card on turn 5.

```{r}
played_vs_optimal %>% 
  filter(p1_spy == FALSE & p2_spy == FALSE, optimal_prob == 0, this_card_played == 1) %>% 
  group_by(this_card, turn) %>% #
  summarise(n_mistakes = n()) %>% 
  pivot_wider(names_from = this_card, values_from = n_mistakes, id_cols = turn)
```

### Spy turns

####When going first (opponent used spy):

```{r}
# Overall
played_vs_optimal %>% 
  filter(p1_spy == FALSE & p2_spy == TRUE, optimal_prob == 0, this_card_played == 1) %>% 
  group_by(this_card) %>% #, turn
  summarise(n_mistakes = n())


# Turn by turn
played_vs_optimal %>% 
  filter(p1_spy == FALSE & p2_spy == TRUE, optimal_prob == 0, this_card_played == 1) %>% 
  group_by(this_card, turn) %>% #
  summarise(n_mistakes = n()) %>% 
  pivot_wider(names_from = this_card, values_from = n_mistakes, id_cols = turn)
```

What should've been played instead? (by turn)

```{r}
# Turn by turn
played_vs_optimal %>% 
  filter(p1_spy == FALSE & p2_spy == TRUE, optimal_prob > 0, this_card_played == 0) %>% 
  group_by(this_card, turn) %>% #
  summarise(n_mistakes = n()) %>% 
  pivot_wider(names_from = this_card, values_from = n_mistakes, id_cols = turn)
```

Actual card vs. optimal card/cards

```{r}
played_vs_optimal %>% 
  filter(turn==3) %>% 
  filter(p1_spy == FALSE & p2_spy == TRUE, optimal_prob > 0, this_card_played == 0) %>% 
  group_by(this_card, actual_card_played) %>% #
  summarise(n_mistakes = n()) %>% 
  pivot_wider(names_from = this_card, values_from = n_mistakes, id_cols = actual_card_played) %>% 
  arrange(actual_card_played)
```

#### When going second (opponent used spy)

```{r}
# Overall
played_vs_optimal %>% 
  filter(p1_spy == TRUE & p2_spy == FALSE, optimal_prob == 0, this_card_played == 1) %>% 
  group_by(this_card) %>% #, turn
  summarise(n_mistakes = n())


# Turn by turn
played_vs_optimal %>% 
  filter(p1_spy == TRUE & p2_spy == FALSE, optimal_prob == 0, this_card_played == 1) %>% 
  group_by(this_card, turn) %>% #
  summarise(n_mistakes = n()) %>% 
  pivot_wider(names_from = this_card, values_from = n_mistakes, id_cols = turn)
```

What should've been played instead? (by turn)

```{r}
# Turn by turn
played_vs_optimal %>% 
  filter(p1_spy == TRUE & p2_spy == FALSE, optimal_prob > 0, this_card_played == 0) %>% 
  group_by(this_card, turn) %>% #
  summarise(n_mistakes = n()) %>% 
  pivot_wider(names_from = this_card, values_from = n_mistakes, id_cols = turn)
```

Actual card vs. optimal card/cards

```{r}
played_vs_optimal %>% 
  filter(turn==3) %>% 
  filter(p1_spy == TRUE & p2_spy == FALSE, optimal_prob > 0, this_card_played == 0) %>% 
  group_by(this_card, actual_card_played) %>% #
  summarise(n_mistakes = n()) %>% 
  pivot_wider(names_from = this_card, values_from = n_mistakes, id_cols = actual_card_played) %>% 
  arrange(actual_card_played)
```

#### Looking at specific error turns

Change the filters here to see the type of turn you want

```{r }
played_vs_optimal %>% 
  filter(this_card == 4) %>% #, turn == 2) %>% # Edit this
  filter(p1_spy == TRUE & p2_spy == FALSE, optimal_prob > 0, this_card_played == 0) 
  

allTurns %>% filter(gamestate_str == 'p1-0134567-p2-0123567-w-02-g-00-s-10-h-00')
```

## Error rates by player

#### Non-spy turns

```{r}

played_vs_optimal %>% 
  filter(this_card_played == 1, !is.na(optimal_prob)) %>% 
  filter(p1_spy == FALSE & p2_spy == FALSE) %>% 
  mutate(absolute_mistake = if_else(this_card_played == 1 & optimal_prob == 0, 1, 0)) %>% 
  group_by(p1_name) %>% 
  summarize(total_mistakes = sum(absolute_mistake),
            total_plays = n(),
            mistake_ratio = mean(absolute_mistake)) %>% 
  arrange(-total_plays)
```

#### Spy turns

Spy turn errors p1_spy = p1 used spy, so p2 chooses second p2_spy = p2 used spy, so p2 chooses first

```{r}

# Pivot to a longer form with player_spied describing which player was spied
played_vs_optimal %>% 
  filter(this_card_played == 1, !is.na(optimal_prob)) %>% 
  filter(p1_spy == TRUE | p2_spy == TRUE) %>% 
  pivot_longer(c(p1_spy, p2_spy), names_to = "player_spied") %>% 
  filter(value == TRUE) %>% select(-value) %>%
  mutate(absolute_mistake = if_else(this_card_played == 1 & optimal_prob == 0, 1, 0)) %>% 
  group_by(p1_name, player_spied) %>% 
  summarize(total_mistakes = sum(absolute_mistake),
            total_plays = n(),
            mistake_ratio = mean(absolute_mistake)) %>% 
  arrange(-total_plays, player_spied) %>% head()
  
```

## Non-absolute errors

### First turn table

```{r}
played_vs_optimal %>%
  filter(turn == 1, this_card_played == 1) %>% 
  group_by(this_card) %>% 
  summarize(n_plays = n(),
            optimal_prob = mean(optimal_prob)) %>% 
  mutate(observed_prob = n_plays / sum(n_plays),
         expected_plays = optimal_prob * sum(n_plays)) %>% 
  kable(digits = 3)
```


#### Overall proportions played by bucket.

Here, we put a player's options into "buckets" based on how often they should optimally play it.

It's less difficult than anticipated to detect these differences, with players playing cards in the "0%" bucket \~10% of the time there's an opportunity to do so. They only play cards in the "100%" bucket 57% of the time. I've included the "bias_proportion" variable as the difference between the proportion played and center of the bucket. The lowest 2 buckets are over-played an the rest are under-played (more severely as the probability increases).

```{r}
prob_buckets <- played_vs_optimal %>% 
  #filter(optimal_prob > 0) %>% 
  #filter(p1_spy == FALSE & p2_spy == FALSE) %>% 
  mutate(prob_bucket = ceiling(optimal_prob*10)/10) %>% 
  group_by(prob_bucket) %>% 
  summarise(n_played = sum(this_card_played),
            n_opportunities = n(),
            prop_played = mean(this_card_played),
            avg_prop_in_bucket = mean(optimal_prob)) %>% 
  mutate(bias_proportion = prop_played - avg_prop_in_bucket,
            expected_plays = avg_prop_in_bucket * n_opportunities)

prob_buckets %>% 
  kable(digits = 2)

prob_buckets%>% 
  ggplot(aes(x = avg_prop_in_bucket, y = prop_played, size = n_opportunities)) +
  geom_point(stat = "identity")  +
  geom_abline(intercept = 0, slope = 1, color = "red") +
  scale_x_continuous(limits = c(0, 1), expand = expansion(add = c(0.01,0.01))) +
  scale_y_continuous(limits = c(0, 1), expand = expansion(add = c(0,0))) +
  labs(title = "Observed cards played vs. optimal probabilities (bucketed)",
       #subtitle = "",
       x = "Average poportion vs. optimal proportion",
       y = "% played")  +
  theme_bw() +
  theme(
    # Remove the y-axis
    axis.title.y = element_blank(),
    axis.text.y = element_blank(),
    # Set x-axis breaks from 0 to 7
    #axis.ticks.x = element_line(),
    #axis.text.x = element_text(size = 10),
    axis.ticks.length.x = unit(0, "cm") # Adjust tick length if needed
  )
```

```{r}

```


Separated by card

```{r}
prob_buckets_by_card <- played_vs_optimal %>% 
  mutate(prob_bucket = if_else(optimal_prob == 0 | optimal_prob == 1, optimal_prob, round(optimal_prob*9)/9)) %>% 
  group_by(prob_bucket, this_card) %>% 
  summarise(n_played = sum(this_card_played),
            n_opportunities = n(),
            prop_played = mean(this_card_played),
            avg_prop_in_bucket = mean(optimal_prob)) 

prob_buckets_by_card %>% 
  arrange(this_card)

prob_buckets_by_card %>% 
  ggplot(aes(x = prob_bucket, y = prop_played)) +
  geom_bar(stat = "identity") +
  facet_grid(rows = vars(this_card))
  
```

### Impact of errors

When a player makes an "error" how does that affect their "win probability"? Are some players making "errors" that are really beneficial predictions of their opponent's move?

```{r}

value_changes <- joined_human_ai %>% 
  group_by(Game, p1_name) %>% 
   # next_turn_value is the value of the next turn. If game is lost, use game outcome
  mutate(next_turn_value = if_else(Turn != max(Turn), lead(value, n=1),
                                if_else(Outcome == "Win", 1, if_else(Outcome == "Loss", 0, 0.5))),
         value_change = next_turn_value - value) %>% 
  left_join(played_vs_optimal %>% filter(this_card_played == 1))
  
# This plot is "Optimal probability of playing the card that was played" vs "change in value of game".
value_changes %>% 
  ggplot(aes(x = optimal_prob, y = value_change, color = P1)) +
  geom_point() +
  geom_smooth()
```

```{r}
value_changes %>% 
  filter(p1_spy == FALSE & p2_spy == FALSE) %>% 
  mutate(abs_mistake = if_else(optimal_prob == 0, "Mistake", "Non-mistake")) %>% 
  group_by(abs_mistake) %>% 
  summarize(avg_change = mean(value_change), 
            std_dev = sd(value_change),
            n = n())

# t-test on difference
SE = (0.2362542/239 + 0.2356995/797)^0.5
t = (-0.028737909 - 0.008617767)/ SE
df = 239 + 797 - 2

pt(t, df=df, lower.tail=TRUE)
```

There appears to be a small, but statistically insignificant difference between the value changes from plays that are "miastakes" vs. non-mistakes.

### Do some cards tend to increase value?

```{r}
value_changes %>% 
  filter(p1_spy == FALSE & p2_spy == FALSE) %>% 
  #mutate(abs_mistake = if_else(optimal_prob == 0, "Mistake", "Non-mistake")) %>% 
  group_by(P1) %>% 
  summarize(avg_change = mean(value_change), 
            std_dev = sd(value_change),
            n = n())
```

# Human EDA

```{r}
joined_human_ai %>% filter(is.na(value)) %>% 
  select(c(paste("p1_c", 0:7, sep=''), paste("p2_c", 0:7, sep=''), 
                                                "p1_wins", "p2_wins", "p1_holds", "p2_holds",
                                                "p1_spy", "p2_spy", "p1_general", "p2_general", "Turn", "Game"))
```

```{r}
allTurns %>% filter(turn==5, p1_holds==2, p2_holds==2)
```

```{r}
joined_human_ai %>% 
  filter(Game==1)
```

### Game plots

```{r}
joined_human_ai %>% 
  mutate(game_player = str_c("Game",Game,p1_name)) %>% 
  ggplot(aes(x = turn, y = value, color=Outcome, group = game_player)) +
  geom_line(alpha = 0.5) +
  facet_grid(rows = vars(Outcome))
```

```{r}
joined_human_ai %>% filter(value==1, Outcome=="Loss")# %>% select()
```



Number of cards played and turns

```{r}
joined_human_ai %>% summarize(n = n(), n_turns = n()/2)
```

### Turns per game

```{r}
turns_per_game <- joined_human_ai %>% 
  group_by(Game) %>% 
  summarize(turns = max(turn)) 

n_games <- nrow(turns_per_game)

hist(turns_per_game$turns)

joined_human_ai %>% 
  filter(Flipped == FALSE) %>% 
  ggplot(aes(x=turn)) +
  geom_bar(fill = 'white', color = "black", size = 1) +
  geom_text(aes(label = ..count..), 
            stat = 'count', 
            vjust = -0.5,  # Vertical adjustment for count
            color = 'black') +
  geom_text(aes(label = scales::percent(..count.. / n_games, accuracy = 0.1)), 
            stat = 'count', 
            vjust = 1.5,  # Vertical adjustment for proportion
            color = 'black') +
  labs(title = "Observed Plays by Turn of Game",
       subtitle = "Count and % of games that reach turn x",
       x = "Turn",
       y = "Games")  +
  theme_minimal() +
  theme(
    # Remove the y-axis
    axis.title.y = element_blank(),
    axis.text.y = element_blank(),
    # Remove grid lines
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    # Set x-axis breaks from 0 to 7
    axis.ticks.x = element_line(),
    axis.text.x = element_text(size = 10),
    axis.ticks.length.x = unit(0, "cm"),  # Adjust tick length if needed
  ) +
  scale_x_continuous(breaks = 1:8) +
  scale_y_continuous(expand = expansion(add = c(0,10)))

mean(turns_per_game$turns)

```


Distinct Game States

```{r}
joined_human_ai %>% 
  distinct(gamestate_str)
```
