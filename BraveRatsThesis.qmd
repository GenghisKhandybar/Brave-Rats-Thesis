---
title: "BraveRatsThesis"
format:
  html:
    toc: true
editor: visual
---

# Setup

allTurns = optimal gameplay data
braverats = human data

```{r}
library(tidyverse)
library(tidyclust)
library(tclust)
library(tidymodels)
```

```{r}
# Main data

allTurns <- read.csv("playableSolutions.txt", header = FALSE, sep = "|", col.names = c("gamestate", "value", ".s1","p1_optimal",".s2", "p2_optimal", ".m", "value_matrix")) %>% 
  mutate(gamestate = substr(gamestate,1, nchar(gamestate)-2)) %>% # Fixing error where extra characters ":v" are added to gamestate
  mutate(gamestate_str = gamestate) %>% #Making a copy to be used as row labels
  separate(gamestate, c(".1", "p1_cards", ".2", "p2_cards", ".3", "wins", ".4", "generals", ".5", "spies", ".6", "holds"), sep = "-")

rownames(allTurns) <- allTurns$gamestate_str
allTurns <- allTurns %>% 
  separate(p1_optimal, paste("p1_o", 0:7, sep=''), sep=",", convert = TRUE) %>% 
  separate(p2_optimal, paste("p2_o", 0:7, sep=''), sep=",", convert = TRUE)

allTurns <- allTurns %>% select(-starts_with(".")) # get rid of temp columns starting with "."
allTurns <- allTurns %>% mutate(cards_left = nchar(p1_cards),
                                turn = 9-cards_left) %>% 
  mutate(p1_c0 = grepl("0",p1_cards),
          p1_c1 = grepl("1",p1_cards),
          p1_c2 = grepl("2",p1_cards),
          p1_c3 = grepl("3",p1_cards),
          p1_c4 = grepl("4",p1_cards),
          p1_c5 = grepl("5",p1_cards),
          p1_c6 = grepl("6",p1_cards),
          p1_c7 = grepl("7",p1_cards),
          p2_c0 = grepl("0",p2_cards),
          p2_c1 = grepl("1",p2_cards),
          p2_c2 = grepl("2",p2_cards),
          p2_c3 = grepl("3",p2_cards),
          p2_c4 = grepl("4",p2_cards),
          p2_c5 = grepl("5",p2_cards),
          p2_c6 = grepl("6",p2_cards),
          p2_c7 = grepl("7",p2_cards),
          p1_wins = as.numeric(substring(wins, 1,1)),
         p2_wins = as.numeric(substring(wins, 2,2)),
         p1_general = substring(generals, 1,1)==1,
         p2_general = substring(generals, 2,2)==1,
         p1_spy = substring(spies, 1,1)==1,
         p2_spy = substring(spies,2,2)==1,
         p1_holds = as.numeric(substring(holds,1,1)),
         p2_holds = as.numeric(substring(holds,2,2))
         )

# c("p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7")
# c("p2_o0","p2_o1","p2_o2","p2_o3","p2_o4","p2_o5","p2_o6","p2_o7")
```

```{r}
allTurns %>% 
  filter(turn == 2) %>% filter(p1_c2==FALSE) %>% 
  head()
```

```{r}
# A dataframe of just the optimal probabilities (0 for non-possibilities)
p1_optimal_turns <- allTurns %>% 
  #filter(turn <=5) %>% 
  filter(p1_spy == 0 && p2_spy == 0) %>% 
  select("p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7") %>% 
  mutate_all(~replace(., is.na(.), 0))
```

### Human data

```{r}
#braverats <- read.csv("BraveRatsData.csv")
source("readHumanData.r")

head(braverats, 30)
```

```{r}
joined_human_ai <- braverats %>% left_join(allTurns, by=c(paste("p1_c", 0:7, sep=''), paste("p2_c", 0:7, sep=''), 
                                                "p1_wins", "p2_wins", "p1_holds", "p2_holds",
                                                "p1_spy", "p2_spy", "p1_general", "p2_general"))
```

# EDA

```{r}
hist(allTurns$value)
```

```{r}
allTurns %>% 
  ggplot(aes(x = turn)) +
  geom_histogram()

allTurns %>% 
  group_by(turn) %>% 
  summarize(count = n())
```

```{r}
allTurns %>% 
  ggplot(aes(x = factor(turn), y = value)) +
  geom_violin()

allTurns %>% 
  ggplot(aes(x = factor(turn), y = value)) +
  geom_point()
```

```{r}
allTurns %>% 
  ggplot(aes(x = value)) +
  geom_histogram() +
  facet_grid(rows = vars(cards_left), scales = "free_y")
```

```{r}
card_optimals <- allTurns %>% 
  pivot_longer(cols = c("p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7"), names_prefix="p1_o", names_to = "card", values_to = "optimal_prob") 

card_optimals %>% 
  ggplot(aes(x = optimal_prob)) +
  geom_histogram(bins = 10) +
  facet_grid(rows = vars(card))
```

```{r}
card_optimals %>% 
  select(card,turn,optimal_prob) %>% 
  filter(!is.na(optimal_prob)) %>% 
  group_by(card,turn) %>% 
  summarize(avg_prob = mean(optimal_prob)) %>% 
  ggplot(aes(x = turn, y = avg_prob, color = card)) +
  geom_line()
  
```

# Clustering

```{r}
k <- 12
kmeans_spec <- k_means(num_clusters=k)

kmeans_fit <- kmeans_spec %>% fit(~p1_o0+p1_o1+p1_o2+p1_o3+p1_o4+p1_o5+p1_o6+p1_o7,data = p1_optimal_turns)

kmeans_fit$fit$tot.withinss
kmeans_fit$fit$betweenss

df_clusters <- kmeans_fit$fit$centers %>% 
  data.frame() %>% mutate(cluster_num = 1:k) %>% 
  pivot_longer(cols = c("p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7"), names_prefix="p1_o", names_to = "card", values_to = "optimal_prob") 

df_clusters %>% 
  ggplot(aes(x = card, y = optimal_prob)) +
  geom_bar(stat = "identity") +
  facet_grid(rows = vars(cluster_num))
```

```{r}
# Total number of turns in each cluster
cluster_info <- allTurns %>% 
  #filter(turn <=5) %>% 
  filter(p1_spy == 0 && p2_spy == 0) %>% 
  mutate(cluster = kmeans_fit$fit$cluster)

cluster_info %>% group_by(cluster) %>% 
  summarize(n = n()) %>% 
  mutate(prop = n/sum(n))
```

## Optimal data for each cluster

```{r}
# What turns are this particular cluster in?

cluster_info %>%
  group_by(turn, cluster) %>% 
  summarize(count = n()) %>% 
  pivot_wider(names_from ="turn", names_prefix="Turn_", values_from=count, id_cols=cluster)

# How are the optimal probabilities distributed in real turns from this cluster?
# TRY TO ADD CENTROIDS TO THIS
cluster_info %>% 
  filter(cluster==3) %>% 
  pivot_longer(cols = c("p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7"),
               names_prefix="p1_o", names_to = "card", values_to = "optimal_prob") %>% 
  ggplot(aes(x = optimal_prob)) +
  geom_histogram(bins = 10) +
  facet_grid(rows = vars(card))
```

**Human data counts in each cluster**

```{r, waring=FALSE}
# Joining human data with clusters
human_clusters <- braverats %>% left_join(cluster_info, by=c(paste("p1_c", 0:7, sep=''), paste("p2_c", 0:7, sep=''), 
                                                "p1_wins", "p2_wins", "p1_holds", "p2_holds",
                                                "p1_spy", "p2_spy", "p1_general", "p2_general"))

# Overall counts and props

human_clusters %>% group_by(cluster) %>% 
  summarize(n = n()) %>% 
  mutate(prop = n/sum(n)) %>% 
  arrange(desc(n))

# By person counts and props

human_clusters %>% group_by(cluster, p1_name) %>% 
  summarize(n = n()) %>% 
  group_by(p1_name) %>% 
  mutate(prop_for_player = n/sum(n)) %>% 
  arrange(desc(n))
```

```{r}
# What turns are each cluster in for humans?

human_clusters %>%
  group_by(turn, cluster) %>% 
  summarize(count = n()) %>% 
  pivot_wider(names_from ="turn", names_prefix="Turn_", values_from=count, id_cols=cluster)

# How are the optimal probabilities distributed in real turns from this cluster?
human_clusters %>% 
  pivot_longer(cols = c("p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7"),
               names_prefix="p1_o", names_to = "card", values_to = "optimal_prob") %>% 
  ggplot(aes(x = optimal_prob)) +
  geom_histogram(bins = 10) +
  facet_grid(rows = vars(card))
```

# Logistic regression

(This task may be better to do in Python actually? Looking into GLM to do the transformation.)

```{r}
df_predictors <- allTurns %>% 
  filter(p1_spy==0, p2_spy==0) %>% 
  select(
  p1_o0,p1_o1,p1_o2,p1_o3,p1_o4,p1_o5,p1_o6,p1_o7, #Outputs
  p1_c0,p1_c1,p1_c2,p1_c3,p1_c4,p1_c5,p1_c6,p1_c7, #Inputs
          p2_c0,p2_c1,p2_c2,p2_c3,p2_c4,p2_c5,p2_c6,p2_c7,
          p1_wins,
         p2_wins,
         p1_general,p2_general,
         #p1_spy,p2_spy,
         p1_holds,p2_holds) %>% 
  mutate_all(~replace(., is.na(.), 0))

#lin_reg_spec <- logistic_reg() %>%
  #set_mode("regression") %>%
#  set_engine("lm")

#ins_lm_fit <- lin_reg_spec %>%
#  fit(p1_o7 ~ p1_c0+p1_c1+p1_c2+p1_c3+p1_c4+p1_c5+p1_c6+p1_c7+ #Inputs
#          p2_c0+p2_c1+p2_c2+p2_c3+p2_c4+p2_c5+p2_c6+p2_c7+
#          p1_wins+
#         p2_wins+
#         p1_general+p2_general+
#         #p1_spy+p2_spy+
#         p1_holds+p2_holds, data = df_predictors) 
#
#ins_lm_fit$fit$coefficients
```

# Spy turns

Given that card X is in hand and you've been spied, how often is card X optimal to play? 

This table is split by turn of game. Contrary to prior belief, card 0 is not the overwhelming preferrence even when it's an option (<50% until turn 5).

```{r}
allTurns %>% 
  filter(p2_spy==1) %>% 
  group_by(turn) %>% 
  summarize(across(c("p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7"), ~mean(.x, na.rm=TRUE)))
```

A manual survey of what cards are optimal during different turns.

```{r}
spy_optimal_cards <- allTurns %>% 
  filter(p2_spy==TRUE) %>% 
  #select(p1_cards, p2_cards, "p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7", "p2_o0","p2_o1","p2_o2","p2_o3","p2_o4","p2_o5","p2_o6","p2_o7") %>% 
  # Extracting the optimal card for each player
  pivot_longer(cols = c( "p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7"), names_to = "p1_card", values_to = "optimal_prob") %>% 
  filter(optimal_prob==1) %>% 
  mutate(p1_card=as.factor(substring(p1_card,5,6))) %>% 
  select(-optimal_prob) %>% 
  pivot_longer(cols = c("p2_o0","p2_o1","p2_o2","p2_o3","p2_o4","p2_o5","p2_o6","p2_o7"), names_to = "p2_card", values_to = "optimal_prob") %>% 
  filter(optimal_prob==1) %>% 
  mutate(p2_card=as.factor(substring(p2_card,5,6))) %>% 
  select(-optimal_prob)

spy_optimal_cards %>% 
  filter(turn<=3) %>% 
  select(p1_cards, p2_cards,wins, generals, holds, p1_card, p2_card) %>% 
  sample_n(10)
```

### Decision tree for spy turns

```{r}
library(rpart)

library(rpart.plot)


tree_mod <- decision_tree(mode = "classification", tree_depth = 4, cost_complexity = double(1)) %>%
  set_engine("rpart") %>%
  set_mode("classification")

spy_recipe = recipe(p1_card ~ #p1_c0+p1_c1+p1_c2+p1_c3+p1_c4+p1_c5+p1_c6+p1_c7+ # All gamestate information
          p2_c0+p2_c1+p2_c2+p2_c3+p2_c4+p2_c5+p2_c6+p2_c7+
          p1_wins+
         p2_wins+
         p1_general+p2_general+
         #p1_spy+p2_spy+
         p1_holds+p2_holds, data = spy_optimal_cards)

spy_wf = workflow() %>%
  add_recipe(spy_recipe) %>%
  add_model(tree_mod)

spy_fit <- spy_wf %>% fit(spy_optimal_cards)

tree_fitted <- spy_fit %>% 
  extract_fit_parsnip()

tree_fitted

rpart.plot(tree_fitted$fit)
```

# Analysis of viability

In this section I use decision trees to see how easy it is to tell whether a card is "viable" in a certain situation or not. A card is "viable" if the optimal probability to play it is above 0.

```{r}
# This dataset looks card-by-card whether each card is viable in a particular gamestate.
# The idea is that if it's simple to tell which cards are viable, we can more easily figure out the play patterns that will work

card_viability <- allTurns %>% 
  filter(p2_spy==FALSE, turn <8) %>% 
  # Extracting the optimal card for each player
  pivot_longer(cols = c( "p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7"), names_to = "p1_card", values_to = "p1_optimal_prob") %>% 
  filter(!is.na(p1_optimal_prob)) %>% 
  mutate(p1_card=as.factor(substring(p1_card,5,6)),
         p1_card_viable = ifelse(p1_optimal_prob>0,"viable","not viable")) %>% 
  pivot_longer(cols = c("p2_o0","p2_o1","p2_o2","p2_o3","p2_o4","p2_o5","p2_o6","p2_o7"), names_to = "p2_card", values_to = "p2_optimal_prob") %>% 
  filter(!is.na(p2_optimal_prob)) %>% 
  mutate(p2_card=as.factor(substring(p2_card,5,6)),
         p2_card_viable = ifelse(p2_optimal_prob>0,"viable","not viable"))

# card_viability %>% sample_n(10)
```

We'll make a tree for each card (I'll just do a few for now to illustrate).

For card 0 (musician)

```{r}
card_of_interest = 0 # Doing each card's tree 1 at a time

tree_mod <- decision_tree(mode = "classification", tree_depth = 3, cost_complexity = double(1)) %>%
  set_engine("rpart") %>%
  set_mode("classification")

spy_recipe = recipe(p1_card_viable ~ #p1_c0+p1_c1+p1_c2+p1_c3+p1_c4+p1_c5+p1_c6+p1_c7+ # All gamestate information
          p2_c0+p2_c1+p2_c2+p2_c3+p2_c4+p2_c5+p2_c6+p2_c7+
          p1_wins+
         p2_wins+
         p1_general+p2_general+
         #p1_spy+p2_spy+
         p1_holds+p2_holds, data = card_viability)

spy_wf = workflow() %>%
  add_recipe(spy_recipe) %>%
  add_model(tree_mod)

spy_fit <- spy_wf %>% fit(card_viability %>% filter(p1_card==card_of_interest))

tree_fitted <- spy_fit %>% 
  extract_fit_parsnip()

tree_fitted

rpart.plot(tree_fitted$fit)
```

For princess (1)

```{r}
card_of_interest = 1 # Doing each card's tree 1 at a time

tree_mod <- decision_tree(mode = "classification", tree_depth = 4, cost_complexity = double(1)) %>%
  set_engine("rpart") %>%
  set_mode("classification")

spy_recipe = recipe(p1_card_viable ~ #p1_c0+p1_c1+p1_c2+p1_c3+p1_c4+p1_c5+p1_c6+p1_c7+ # All gamestate information
          p2_c0+p2_c1+p2_c2+p2_c3+p2_c4+p2_c5+p2_c6+p2_c7+
          p1_wins+
         p2_wins+
         p1_general+p2_general+
         #p1_spy+p2_spy+
         p1_holds+p2_holds, data = card_viability)

spy_wf = workflow() %>%
  add_recipe(spy_recipe) %>%
  add_model(tree_mod)

spy_fit <- spy_wf %>% fit(card_viability %>% filter(p1_card==card_of_interest))

tree_fitted <- spy_fit %>% 
  extract_fit_parsnip()

tree_fitted

rpart.plot(tree_fitted$fit)
```

For card 7 (Prince)

```{r}
card_of_interest = 7 # Doing each card's tree 1 at a time

tree_mod <- decision_tree(mode = "classification", tree_depth = 4, cost_complexity = double(1)) %>%
  set_engine("rpart") %>%
  set_mode("classification")

spy_recipe = recipe(p1_card_viable ~ #p1_c0+p1_c1+p1_c2+p1_c3+p1_c4+p1_c5+p1_c6+p1_c7+ # All gamestate information
          p2_c0+p2_c1+p2_c2+p2_c3+p2_c4+p2_c5+p2_c6+p2_c7+
          p1_wins+
         p2_wins+
         p1_general+p2_general+
         #p1_spy+p2_spy+
         p1_holds+p2_holds, data = card_viability)

spy_wf = workflow() %>%
  add_recipe(spy_recipe) %>%
  add_model(tree_mod)

spy_fit <- spy_wf %>% fit(card_viability %>% filter(p1_card==card_of_interest))

tree_fitted <- spy_fit %>% 
  extract_fit_parsnip()

tree_fitted

rpart.plot(tree_fitted$fit)
  
```

# Human conformity to optimal

In this section, we're looking at every card a player had the option to play, the optimal probability to play it, and whether they played it. 

```{r}
played_vs_optimal <- joined_human_ai %>% 
  pivot_longer(cols = c("p1_o0","p1_o1","p1_o2","p1_o3","p1_o4","p1_o5","p1_o6","p1_o7"), names_to = "card_untrimmed", values_to = "optimal_prob") %>%
  mutate(this_card = substring(card_untrimmed, 5,6),
         this_card_played = if_else(P1==this_card, 1, 0)) %>% 
  select(Game, turn, p1_name, this_card, this_card_played, optimal_prob, gamestate_str, p1_spy, p2_spy) %>% 
  filter(!is.na(optimal_prob)) # Removing invalid cards

played_vs_optimal %>% sample_n(8)
```


## Absolute mistakes

"Absolute mistake" = playing a card with optimal probability of 0. These plays are against theory, but may still be beneficial if you have a confident prediction about your opponent's choice. 

Which cards are most often played when they shouldn't have?

Counts of all absolute mistakes made by card

```{r}
played_vs_optimal %>% 
  filter(p1_spy == FALSE & p2_spy == FALSE, optimal_prob == 0, this_card_played == 1) %>% 
  group_by(this_card) %>% #, turn
  summarise(n_mistakes = n())
```


Turn-by-turn view: Column = card, row = turn of game. The most common "absolute mistakes" are playing the 6 card on turn 1, the 0 card on turn 3, and the 1 card on turn 5.

```{r}
played_vs_optimal %>% 
  filter(p1_spy == FALSE & p2_spy == FALSE, optimal_prob == 0, this_card_played == 1) %>% 
  group_by(this_card, turn) %>% #
  summarise(n_mistakes = n()) %>% 
  pivot_wider(names_from = this_card, values_from = n_mistakes, id_cols = turn)
```


### Error rates by player 

#### Non-spy turns

```{r}

played_vs_optimal %>% 
  filter(this_card_played == 1, !is.na(optimal_prob)) %>% 
  filter(p1_spy == FALSE & p2_spy == FALSE) %>% 
  mutate(absolute_mistake = if_else(this_card_played == 1 & optimal_prob == 0, 1, 0)) %>% 
  group_by(p1_name) %>% 
  summarize(total_mistakes = sum(absolute_mistake),
            total_plays = n(),
            mistake_ratio = mean(absolute_mistake)) %>% 
  arrange(-total_plays)
```

#### Spy turns

Spy turn errors 
p1_spy = p1 used spy, so p2 chooses second
p2_spy = p2 used spy, so p2 chooses first

```{r}

# Pivot to a longer form with player_spied describing which player was spied
played_vs_optimal %>% 
  filter(this_card_played == 1, !is.na(optimal_prob)) %>% 
  filter(p1_spy == TRUE | p2_spy == TRUE) %>% 
  pivot_longer(c(p1_spy, p2_spy), names_to = "player_spied") %>% 
  filter(value == TRUE) %>% select(-value) %>%
  mutate(absolute_mistake = if_else(this_card_played == 1 & optimal_prob == 0, 1, 0)) %>% 
  group_by(p1_name, player_spied) %>% 
  summarize(total_mistakes = sum(absolute_mistake),
            total_plays = n(),
            mistake_ratio = mean(absolute_mistake)) %>% 
  arrange(-total_plays, player_spied) %>% head()
  
```

## Non-absolute errors

#### Overall proportions played by bucket.

Here, we put a player's options into "buckets" based on how often they should optimally play it.

It's less difficult than anticipated to detect these differences, with players playing cards in the "0%" bucket ~10% of the time there's an opportunity to do so. They only play cards in the "100%" bucket 57% of the time. I've included the "bias_proportion" variable as the difference between the proportion played and center of the bucket. The lowest 2 buckets are over-played an the rest are under-played (more severely as the probability increases).

```{r}
prob_buckets <- played_vs_optimal %>% 
  filter(p1_spy == FALSE & p2_spy == FALSE) %>% 
  mutate(prob_bucket = if_else(optimal_prob == 0 | optimal_prob == 1, optimal_prob, round(optimal_prob*9)/9)) %>% 
  group_by(prob_bucket) %>% 
  summarise(n_played = sum(this_card_played),
            n_opportunities = n(),
            prop_played = mean(this_card_played),
            avg_prop_in_bucket = mean(optimal_prob)) %>% 
  mutate(bias_proportion = prop_played - avg_prop_in_bucket)

prob_buckets

prob_buckets%>% 
  ggplot(aes(x = prob_bucket, y = prop_played)) +
  geom_bar(stat = "identity")
```

Separated by card

```{r}
prob_buckets_by_card <- played_vs_optimal %>% 
  mutate(prob_bucket = if_else(optimal_prob == 0 | optimal_prob == 1, optimal_prob, round(optimal_prob*9)/9)) %>% 
  group_by(prob_bucket, this_card) %>% 
  summarise(n_played = sum(this_card_played),
            n_opportunities = n(),
            prop_played = mean(this_card_played),
            avg_prop_in_bucket = mean(optimal_prob)) 

prob_buckets_by_card %>% 
  arrange(this_card)

prob_buckets_by_card %>% 
  ggplot(aes(x = prob_bucket, y = prop_played)) +
  geom_bar(stat = "identity") +
  facet_grid(rows = vars(this_card))
  
```

### Impact of errors

When a player makes an "error" how does that affect their "win probability"? Are some players making "errors" that are really beneficial predictions of their opponent's move?
